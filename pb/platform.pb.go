// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pb/platform.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type RPCSetNetworkRequest struct {
	ClientVersion string `protobuf:"bytes,1,opt,name=clientVersion" json:"clientVersion,omitempty"`
	NetworkKey    string `protobuf:"bytes,2,opt,name=networkKey" json:"networkKey,omitempty"`
	PrivateKey    bool   `protobuf:"varint,3,opt,name=privateKey" json:"privateKey,omitempty"`
}

func (m *RPCSetNetworkRequest) Reset()                    { *m = RPCSetNetworkRequest{} }
func (m *RPCSetNetworkRequest) String() string            { return proto.CompactTextString(m) }
func (*RPCSetNetworkRequest) ProtoMessage()               {}
func (*RPCSetNetworkRequest) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

func (m *RPCSetNetworkRequest) GetClientVersion() string {
	if m != nil {
		return m.ClientVersion
	}
	return ""
}

func (m *RPCSetNetworkRequest) GetNetworkKey() string {
	if m != nil {
		return m.NetworkKey
	}
	return ""
}

func (m *RPCSetNetworkRequest) GetPrivateKey() bool {
	if m != nil {
		return m.PrivateKey
	}
	return false
}

type RPCSetNetworkResponse struct {
	Version string `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
}

func (m *RPCSetNetworkResponse) Reset()                    { *m = RPCSetNetworkResponse{} }
func (m *RPCSetNetworkResponse) String() string            { return proto.CompactTextString(m) }
func (*RPCSetNetworkResponse) ProtoMessage()               {}
func (*RPCSetNetworkResponse) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{1} }

func (m *RPCSetNetworkResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type RPCHealthRequest struct {
}

func (m *RPCHealthRequest) Reset()                    { *m = RPCHealthRequest{} }
func (m *RPCHealthRequest) String() string            { return proto.CompactTextString(m) }
func (*RPCHealthRequest) ProtoMessage()               {}
func (*RPCHealthRequest) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{2} }

type RPCHealthReply struct {
	Ready   bool   `protobuf:"varint,1,opt,name=ready" json:"ready,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *RPCHealthReply) Reset()                    { *m = RPCHealthReply{} }
func (m *RPCHealthReply) String() string            { return proto.CompactTextString(m) }
func (*RPCHealthReply) ProtoMessage()               {}
func (*RPCHealthReply) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{3} }

func (m *RPCHealthReply) GetReady() bool {
	if m != nil {
		return m.Ready
	}
	return false
}

func (m *RPCHealthReply) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*RPCSetNetworkRequest)(nil), "pb.RPCSetNetworkRequest")
	proto.RegisterType((*RPCSetNetworkResponse)(nil), "pb.RPCSetNetworkResponse")
	proto.RegisterType((*RPCHealthRequest)(nil), "pb.RPCHealthRequest")
	proto.RegisterType((*RPCHealthReply)(nil), "pb.RPCHealthReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Decentralizer service

type DecentralizerClient interface {
	//
	// Platform
	//
	// Get health of decentralizer.
	GetHealth(ctx context.Context, in *RPCHealthRequest, opts ...grpc.CallOption) (*RPCHealthReply, error)
	// Set the public or private key of a network
	SetNetwork(ctx context.Context, in *RPCSetNetworkRequest, opts ...grpc.CallOption) (*RPCSetNetworkResponse, error)
	//
	// Matchmaking
	//
	// Create or update a session. Takes session info, returns session id.
	UpsertSession(ctx context.Context, in *RPCUpsertSessionRequest, opts ...grpc.CallOption) (*RPCUpsertSessionResponse, error)
	// Delete a session. Takes session id, returns bool informing if the deletion was a success
	DeleteSession(ctx context.Context, in *RPCDeleteSessionRequest, opts ...grpc.CallOption) (*RPCDeleteSessionResponse, error)
	// Get session ids. Takes session type, and a key and value to filter the sessions by details. If left empty this filter will not apply  and all will be fetched.
	GetSessionIds(ctx context.Context, in *RPCGetSessionIdsRequest, opts ...grpc.CallOption) (*RPCGetSessionIdsResponse, error)
	// Get an individual session. Takes session id and returns session info.
	GetSession(ctx context.Context, in *RPCGetSessionRequest, opts ...grpc.CallOption) (*RPCGetSessionResponse, error)
	//
	// Address book
	//
	// Create or update a peer. Takes peer info, returns if it was a success.
	UpsertPeer(ctx context.Context, in *RPCUpsertPeerRequest, opts ...grpc.CallOption) (*RPCUpsertPeerResponse, error)
	// Get peer ids. takes a key and value to filter the peers by details. If left empty this filter will not apply and all will be fetched.
	GetPeerIds(ctx context.Context, in *RPCGetPeerIdsRequest, opts ...grpc.CallOption) (*RPCGetPeerIdsResponse, error)
	// Get an individual peer. Takes either a peer id or decentralizer id and returns the peer info.
	GetPeer(ctx context.Context, in *RPCGetPeerRequest, opts ...grpc.CallOption) (*RPCGetPeerResponse, error)
	//
	// Storage
	//
	// Write a peer file. Takes a file name and the data it should save.
	WritePeerFile(ctx context.Context, in *RPCWritePeerFileRequest, opts ...grpc.CallOption) (*RPCWritePeerFileResponse, error)
	// Get a peer file. Takes a file name, returns the file.
	GetPeerFile(ctx context.Context, in *RPCGetPeerFileRequest, opts ...grpc.CallOption) (*RPCGetPeerFileResponse, error)
	// Get a publisher file.
	GetPublisherFile(ctx context.Context, in *RPCGetPublisherFileRequest, opts ...grpc.CallOption) (*RPCGetPublisherFileResponse, error)
	//
	// Messaging
	//
	// Send another peer a direct message. Takes a peer id and the data it should send
	SendDirectMessage(ctx context.Context, in *RPCDirectMessageRequest, opts ...grpc.CallOption) (*RPCDirectMessageResponse, error)
}

type decentralizerClient struct {
	cc *grpc.ClientConn
}

func NewDecentralizerClient(cc *grpc.ClientConn) DecentralizerClient {
	return &decentralizerClient{cc}
}

func (c *decentralizerClient) GetHealth(ctx context.Context, in *RPCHealthRequest, opts ...grpc.CallOption) (*RPCHealthReply, error) {
	out := new(RPCHealthReply)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetHealth", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) SetNetwork(ctx context.Context, in *RPCSetNetworkRequest, opts ...grpc.CallOption) (*RPCSetNetworkResponse, error) {
	out := new(RPCSetNetworkResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/SetNetwork", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) UpsertSession(ctx context.Context, in *RPCUpsertSessionRequest, opts ...grpc.CallOption) (*RPCUpsertSessionResponse, error) {
	out := new(RPCUpsertSessionResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/UpsertSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) DeleteSession(ctx context.Context, in *RPCDeleteSessionRequest, opts ...grpc.CallOption) (*RPCDeleteSessionResponse, error) {
	out := new(RPCDeleteSessionResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/DeleteSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) GetSessionIds(ctx context.Context, in *RPCGetSessionIdsRequest, opts ...grpc.CallOption) (*RPCGetSessionIdsResponse, error) {
	out := new(RPCGetSessionIdsResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetSessionIds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) GetSession(ctx context.Context, in *RPCGetSessionRequest, opts ...grpc.CallOption) (*RPCGetSessionResponse, error) {
	out := new(RPCGetSessionResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) UpsertPeer(ctx context.Context, in *RPCUpsertPeerRequest, opts ...grpc.CallOption) (*RPCUpsertPeerResponse, error) {
	out := new(RPCUpsertPeerResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/UpsertPeer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) GetPeerIds(ctx context.Context, in *RPCGetPeerIdsRequest, opts ...grpc.CallOption) (*RPCGetPeerIdsResponse, error) {
	out := new(RPCGetPeerIdsResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetPeerIds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) GetPeer(ctx context.Context, in *RPCGetPeerRequest, opts ...grpc.CallOption) (*RPCGetPeerResponse, error) {
	out := new(RPCGetPeerResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetPeer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) WritePeerFile(ctx context.Context, in *RPCWritePeerFileRequest, opts ...grpc.CallOption) (*RPCWritePeerFileResponse, error) {
	out := new(RPCWritePeerFileResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/WritePeerFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) GetPeerFile(ctx context.Context, in *RPCGetPeerFileRequest, opts ...grpc.CallOption) (*RPCGetPeerFileResponse, error) {
	out := new(RPCGetPeerFileResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetPeerFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) GetPublisherFile(ctx context.Context, in *RPCGetPublisherFileRequest, opts ...grpc.CallOption) (*RPCGetPublisherFileResponse, error) {
	out := new(RPCGetPublisherFileResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetPublisherFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) SendDirectMessage(ctx context.Context, in *RPCDirectMessageRequest, opts ...grpc.CallOption) (*RPCDirectMessageResponse, error) {
	out := new(RPCDirectMessageResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/SendDirectMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Decentralizer service

type DecentralizerServer interface {
	//
	// Platform
	//
	// Get health of decentralizer.
	GetHealth(context.Context, *RPCHealthRequest) (*RPCHealthReply, error)
	// Set the public or private key of a network
	SetNetwork(context.Context, *RPCSetNetworkRequest) (*RPCSetNetworkResponse, error)
	//
	// Matchmaking
	//
	// Create or update a session. Takes session info, returns session id.
	UpsertSession(context.Context, *RPCUpsertSessionRequest) (*RPCUpsertSessionResponse, error)
	// Delete a session. Takes session id, returns bool informing if the deletion was a success
	DeleteSession(context.Context, *RPCDeleteSessionRequest) (*RPCDeleteSessionResponse, error)
	// Get session ids. Takes session type, and a key and value to filter the sessions by details. If left empty this filter will not apply  and all will be fetched.
	GetSessionIds(context.Context, *RPCGetSessionIdsRequest) (*RPCGetSessionIdsResponse, error)
	// Get an individual session. Takes session id and returns session info.
	GetSession(context.Context, *RPCGetSessionRequest) (*RPCGetSessionResponse, error)
	//
	// Address book
	//
	// Create or update a peer. Takes peer info, returns if it was a success.
	UpsertPeer(context.Context, *RPCUpsertPeerRequest) (*RPCUpsertPeerResponse, error)
	// Get peer ids. takes a key and value to filter the peers by details. If left empty this filter will not apply and all will be fetched.
	GetPeerIds(context.Context, *RPCGetPeerIdsRequest) (*RPCGetPeerIdsResponse, error)
	// Get an individual peer. Takes either a peer id or decentralizer id and returns the peer info.
	GetPeer(context.Context, *RPCGetPeerRequest) (*RPCGetPeerResponse, error)
	//
	// Storage
	//
	// Write a peer file. Takes a file name and the data it should save.
	WritePeerFile(context.Context, *RPCWritePeerFileRequest) (*RPCWritePeerFileResponse, error)
	// Get a peer file. Takes a file name, returns the file.
	GetPeerFile(context.Context, *RPCGetPeerFileRequest) (*RPCGetPeerFileResponse, error)
	// Get a publisher file.
	GetPublisherFile(context.Context, *RPCGetPublisherFileRequest) (*RPCGetPublisherFileResponse, error)
	//
	// Messaging
	//
	// Send another peer a direct message. Takes a peer id and the data it should send
	SendDirectMessage(context.Context, *RPCDirectMessageRequest) (*RPCDirectMessageResponse, error)
}

func RegisterDecentralizerServer(s *grpc.Server, srv DecentralizerServer) {
	s.RegisterService(&_Decentralizer_serviceDesc, srv)
}

func _Decentralizer_GetHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCHealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetHealth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetHealth(ctx, req.(*RPCHealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_SetNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCSetNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).SetNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/SetNetwork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).SetNetwork(ctx, req.(*RPCSetNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_UpsertSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCUpsertSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).UpsertSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/UpsertSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).UpsertSession(ctx, req.(*RPCUpsertSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_DeleteSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCDeleteSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).DeleteSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/DeleteSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).DeleteSession(ctx, req.(*RPCDeleteSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_GetSessionIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCGetSessionIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetSessionIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetSessionIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetSessionIds(ctx, req.(*RPCGetSessionIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_GetSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCGetSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetSession(ctx, req.(*RPCGetSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_UpsertPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCUpsertPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).UpsertPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/UpsertPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).UpsertPeer(ctx, req.(*RPCUpsertPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_GetPeerIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCGetPeerIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetPeerIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetPeerIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetPeerIds(ctx, req.(*RPCGetPeerIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_GetPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCGetPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetPeer(ctx, req.(*RPCGetPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_WritePeerFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCWritePeerFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).WritePeerFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/WritePeerFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).WritePeerFile(ctx, req.(*RPCWritePeerFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_GetPeerFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCGetPeerFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetPeerFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetPeerFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetPeerFile(ctx, req.(*RPCGetPeerFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_GetPublisherFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCGetPublisherFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetPublisherFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetPublisherFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetPublisherFile(ctx, req.(*RPCGetPublisherFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_SendDirectMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCDirectMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).SendDirectMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/SendDirectMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).SendDirectMessage(ctx, req.(*RPCDirectMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Decentralizer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Decentralizer",
	HandlerType: (*DecentralizerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetHealth",
			Handler:    _Decentralizer_GetHealth_Handler,
		},
		{
			MethodName: "SetNetwork",
			Handler:    _Decentralizer_SetNetwork_Handler,
		},
		{
			MethodName: "UpsertSession",
			Handler:    _Decentralizer_UpsertSession_Handler,
		},
		{
			MethodName: "DeleteSession",
			Handler:    _Decentralizer_DeleteSession_Handler,
		},
		{
			MethodName: "GetSessionIds",
			Handler:    _Decentralizer_GetSessionIds_Handler,
		},
		{
			MethodName: "GetSession",
			Handler:    _Decentralizer_GetSession_Handler,
		},
		{
			MethodName: "UpsertPeer",
			Handler:    _Decentralizer_UpsertPeer_Handler,
		},
		{
			MethodName: "GetPeerIds",
			Handler:    _Decentralizer_GetPeerIds_Handler,
		},
		{
			MethodName: "GetPeer",
			Handler:    _Decentralizer_GetPeer_Handler,
		},
		{
			MethodName: "WritePeerFile",
			Handler:    _Decentralizer_WritePeerFile_Handler,
		},
		{
			MethodName: "GetPeerFile",
			Handler:    _Decentralizer_GetPeerFile_Handler,
		},
		{
			MethodName: "GetPublisherFile",
			Handler:    _Decentralizer_GetPublisherFile_Handler,
		},
		{
			MethodName: "SendDirectMessage",
			Handler:    _Decentralizer_SendDirectMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/platform.proto",
}

func init() { proto.RegisterFile("pb/platform.proto", fileDescriptor3) }

var fileDescriptor3 = []byte{
	// 493 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x94, 0xcf, 0x6e, 0x13, 0x31,
	0x10, 0x87, 0x9b, 0x22, 0x48, 0x3b, 0x28, 0x28, 0xb5, 0x52, 0x14, 0x02, 0x2a, 0xd5, 0x8a, 0x43,
	0x4f, 0x89, 0x80, 0x03, 0x12, 0x27, 0xa4, 0x44, 0x2d, 0x88, 0x3f, 0x8a, 0x36, 0x2a, 0x9c, 0xbd,
	0xd9, 0x21, 0xb1, 0xe2, 0xac, 0x8d, 0xed, 0x16, 0x05, 0xf1, 0x72, 0xbc, 0x19, 0xda, 0x5d, 0xaf,
	0xd7, 0x76, 0xd3, 0xa3, 0xbf, 0x9f, 0xe7, 0xf3, 0xcc, 0x68, 0x13, 0x38, 0x91, 0xd9, 0x44, 0x72,
	0x6a, 0x7e, 0x0a, 0xb5, 0x1d, 0x4b, 0x25, 0x8c, 0x20, 0x87, 0x32, 0x1b, 0x0d, 0x64, 0x36, 0xd9,
	0x52, 0xb3, 0x5c, 0x6f, 0xe9, 0x86, 0x15, 0xab, 0x3a, 0xa9, 0x28, 0xcd, 0x73, 0x85, 0x5a, 0x67,
	0x42, 0x6c, 0x2c, 0xed, 0xcb, 0x6c, 0xa2, 0x8d, 0x50, 0x74, 0x85, 0x96, 0x90, 0xb2, 0x1a, 0xb5,
	0xa6, 0x2b, 0x57, 0x9b, 0xfc, 0x85, 0x41, 0x3a, 0x9f, 0x2e, 0xd0, 0x7c, 0x43, 0xf3, 0x5b, 0xa8,
	0x4d, 0x8a, 0xbf, 0x6e, 0x50, 0x1b, 0xf2, 0x0a, 0x7a, 0x4b, 0xce, 0xb0, 0x30, 0xdf, 0x51, 0x69,
	0x26, 0x8a, 0x61, 0xe7, 0xbc, 0x73, 0x71, 0x9c, 0x86, 0x90, 0x9c, 0x01, 0x14, 0x75, 0xdd, 0x67,
	0xdc, 0x0d, 0x0f, 0xab, 0x2b, 0x1e, 0x29, 0x73, 0xa9, 0xd8, 0x2d, 0x35, 0x58, 0xe6, 0x0f, 0xce,
	0x3b, 0x17, 0x47, 0xa9, 0x47, 0x92, 0xd7, 0x70, 0x1a, 0xbd, 0xae, 0xa5, 0x28, 0x34, 0x92, 0x21,
	0x74, 0x6f, 0x83, 0x87, 0x9b, 0x63, 0x42, 0xa0, 0x9f, 0xce, 0xa7, 0x1f, 0x91, 0x72, 0xb3, 0xb6,
	0xcd, 0x26, 0x1f, 0xe0, 0x89, 0xc7, 0x24, 0xdf, 0x91, 0x01, 0x3c, 0x54, 0x48, 0xf3, 0x5d, 0x55,
	0x7d, 0x94, 0xd6, 0x87, 0xd2, 0x5a, 0xcf, 0x8f, 0xb6, 0xd7, 0xe6, 0xf8, 0xe6, 0x5f, 0x17, 0x7a,
	0x33, 0x5c, 0x62, 0x61, 0x14, 0xe5, 0xec, 0x0f, 0x2a, 0xf2, 0x0e, 0x8e, 0xaf, 0xd0, 0xd4, 0x4e,
	0x32, 0x18, 0xcb, 0x6c, 0x1c, 0x3f, 0x3b, 0x22, 0x11, 0x95, 0x7c, 0x97, 0x1c, 0x90, 0x29, 0x40,
	0x3b, 0x10, 0x19, 0xda, 0x3b, 0x77, 0x36, 0x3c, 0x7a, 0xb6, 0x27, 0xa9, 0xa7, 0x4f, 0x0e, 0xc8,
	0x17, 0xe8, 0x5d, 0x4b, 0x8d, 0xca, 0x2c, 0x50, 0x57, 0x9b, 0x7e, 0x6e, 0x6f, 0x07, 0xb4, 0x51,
	0xbd, 0xd8, 0x1f, 0xfa, 0xb6, 0x19, 0x72, 0x34, 0x18, 0xdb, 0x02, 0x1a, 0xdb, 0xa2, 0xd0, 0xb7,
	0x5d, 0x61, 0xf3, 0xca, 0xa7, 0x5c, 0x3b, 0x5b, 0x40, 0x63, 0x5b, 0x14, 0x3a, 0xdb, 0x14, 0xa0,
	0x8d, 0xdc, 0xba, 0x5a, 0x14, 0xaf, 0xcb, 0x4f, 0x7c, 0x49, 0x3d, 0xfb, 0x1c, 0x51, 0x39, 0x49,
	0x8b, 0x62, 0x89, 0x9f, 0x44, 0x9d, 0x94, 0xb0, 0x1c, 0xca, 0xeb, 0xc4, 0xa2, 0x3d, 0x9d, 0xb8,
	0xc4, 0x49, 0xde, 0x43, 0xd7, 0x72, 0x72, 0x1a, 0xde, 0x6b, 0xca, 0x9f, 0xc6, 0xd8, 0x5f, 0xec,
	0x0f, 0xc5, 0x0c, 0x96, 0xf8, 0x92, 0x71, 0x74, 0x8b, 0x0d, 0x68, 0xbc, 0xd8, 0x28, 0x74, 0xb6,
	0x4b, 0x78, 0x6c, 0x9f, 0xa8, 0x5c, 0x51, 0xd7, 0xbe, 0x69, 0xb4, 0x2f, 0x72, 0x9e, 0x6b, 0xe8,
	0x97, 0xc1, 0x4d, 0xc6, 0x99, 0x5e, 0x5b, 0xd9, 0x99, 0x57, 0xe1, 0x07, 0x8d, 0xf1, 0xe5, 0xbd,
	0xb9, 0xd3, 0xce, 0xe1, 0x64, 0x81, 0x45, 0x3e, 0x63, 0x0a, 0x97, 0xe6, 0x6b, 0xfd, 0x33, 0x6c,
	0xbf, 0x4b, 0x9f, 0xde, 0xf9, 0x2e, 0xc3, 0xb0, 0x31, 0x66, 0x8f, 0xaa, 0x7f, 0xb4, 0xb7, 0xff,
	0x03, 0x00, 0x00, 0xff, 0xff, 0x4b, 0x3e, 0x70, 0x68, 0x3c, 0x05, 0x00, 0x00,
}
