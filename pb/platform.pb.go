// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pb/platform.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

type RPCHealthRequest struct {
	WaitForMinConnections bool `protobuf:"varint,1,opt,name=waitForMinConnections" json:"waitForMinConnections,omitempty"`
}

func (m *RPCHealthRequest) Reset()                    { *m = RPCHealthRequest{} }
func (m *RPCHealthRequest) String() string            { return proto.CompactTextString(m) }
func (*RPCHealthRequest) ProtoMessage()               {}
func (*RPCHealthRequest) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{1} }

func (m *RPCHealthRequest) GetWaitForMinConnections() bool {
	if m != nil {
		return m.WaitForMinConnections
	}
	return false
}

type RPCHealthReply struct {
	Ready          bool   `protobuf:"varint,1,opt,name=ready" json:"ready,omitempty"`
	Message        string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	BasePath       string `protobuf:"bytes,3,opt,name=basePath" json:"basePath,omitempty"`
	NumConnections uint32 `protobuf:"varint,4,opt,name=numConnections" json:"numConnections,omitempty"`
}

func (m *RPCHealthReply) Reset()                    { *m = RPCHealthReply{} }
func (m *RPCHealthReply) String() string            { return proto.CompactTextString(m) }
func (*RPCHealthReply) ProtoMessage()               {}
func (*RPCHealthReply) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{2} }

func (m *RPCHealthReply) GetReady() bool {
	if m != nil {
		return m.Ready
	}
	return false
}

func (m *RPCHealthReply) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *RPCHealthReply) GetBasePath() string {
	if m != nil {
		return m.BasePath
	}
	return ""
}

func (m *RPCHealthReply) GetNumConnections() uint32 {
	if m != nil {
		return m.NumConnections
	}
	return 0
}

func init() {
	proto.RegisterType((*Empty)(nil), "pb.empty")
	proto.RegisterType((*RPCHealthRequest)(nil), "pb.RPCHealthRequest")
	proto.RegisterType((*RPCHealthReply)(nil), "pb.RPCHealthReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Decentralizer service

type DecentralizerClient interface {
	//
	// Platform
	//
	// Get health of decentralizer.
	GetHealth(ctx context.Context, in *RPCHealthRequest, opts ...grpc.CallOption) (*RPCHealthReply, error)
	//
	// Matchmaking
	//
	// Create or update a session. Takes session info, returns session id.
	UpsertSession(ctx context.Context, in *RPCUpsertSessionRequest, opts ...grpc.CallOption) (*RPCUpsertSessionResponse, error)
	// Delete a session. Takes session id, returns bool informing if the deletion was a success
	DeleteSession(ctx context.Context, in *RPCDeleteSessionRequest, opts ...grpc.CallOption) (*RPCDeleteSessionResponse, error)
	// Get session ids. Takes session type, and a key and value to filter the sessions by details. If left empty this filter will not apply and all will be fetched.
	GetSessionIdsByDetails(ctx context.Context, in *RPCGetSessionIdsByDetailsRequest, opts ...grpc.CallOption) (*RPCGetSessionIdsResponse, error)
	// Get session ids. Takes peer ids. Returns session ids
	GetSessionIdsByPeerIds(ctx context.Context, in *RPCGetSessionIdsByPeerIdsRequest, opts ...grpc.CallOption) (*RPCGetSessionIdsResponse, error)
	// Get an individual session. Takes session id and returns session info.
	GetSession(ctx context.Context, in *RPCGetSessionRequest, opts ...grpc.CallOption) (*RPCGetSessionResponse, error)
	//
	// Address book
	//
	// Create or update a peer. Takes peer info, returns if it was a success.
	UpsertPeer(ctx context.Context, in *RPCUpsertPeerRequest, opts ...grpc.CallOption) (*RPCUpsertPeerResponse, error)
	// Get peer ids. takes a key and value to filter the peers by details. If left empty this filter will not apply and all will be fetched.
	GetPeerIds(ctx context.Context, in *RPCGetPeerIdsRequest, opts ...grpc.CallOption) (*RPCGetPeerIdsResponse, error)
	// Get an individual peer. Takes either a peer id or decentralizer id and returns the peer info.
	GetPeer(ctx context.Context, in *RPCGetPeerRequest, opts ...grpc.CallOption) (*RPCGetPeerResponse, error)
	//
	// Storage
	//
	// Write a peer file. Takes a file name and the data it should save.
	WritePeerFile(ctx context.Context, in *RPCWritePeerFileRequest, opts ...grpc.CallOption) (*RPCWritePeerFileResponse, error)
	// Get a peer file. Takes a file name, returns the file.
	GetPeerFile(ctx context.Context, in *RPCGetPeerFileRequest, opts ...grpc.CallOption) (*RPCGetPeerFileResponse, error)
	//
	// Messaging
	//
	// Send another peer a direct message. Takes a peer id and the data it should send
	SendDirectMessage(ctx context.Context, in *RPCDirectMessage, opts ...grpc.CallOption) (*Empty, error)
	ReceiveDirectMessage(ctx context.Context, in *RPCReceiveDirectMessageRequest, opts ...grpc.CallOption) (Decentralizer_ReceiveDirectMessageClient, error)
	//
	// Publisher
	//
	// Load a publisher definition. Will not work if its older!
	ReadPublisherDefinition(ctx context.Context, in *LoadPublisherDefinitionRequest, opts ...grpc.CallOption) (*Empty, error)
	// Signs a new publisher update. (Only if you have the private key!)
	PublishPublisherUpdate(ctx context.Context, in *RPCPublishPublisherUpdateRequest, opts ...grpc.CallOption) (*DNPublisherRecord, error)
	// Get the full publisher definition
	GetPublisherDefinition(ctx context.Context, in *GetPublisherDefinitionRequest, opts ...grpc.CallOption) (*PublisherDefinition, error)
	// Get a publisher file.
	GetPublisherFile(ctx context.Context, in *RPCGetPublisherFileRequest, opts ...grpc.CallOption) (*RPCGetPublisherFileResponse, error)
}

type decentralizerClient struct {
	cc *grpc.ClientConn
}

func NewDecentralizerClient(cc *grpc.ClientConn) DecentralizerClient {
	return &decentralizerClient{cc}
}

func (c *decentralizerClient) GetHealth(ctx context.Context, in *RPCHealthRequest, opts ...grpc.CallOption) (*RPCHealthReply, error) {
	out := new(RPCHealthReply)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetHealth", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) UpsertSession(ctx context.Context, in *RPCUpsertSessionRequest, opts ...grpc.CallOption) (*RPCUpsertSessionResponse, error) {
	out := new(RPCUpsertSessionResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/UpsertSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) DeleteSession(ctx context.Context, in *RPCDeleteSessionRequest, opts ...grpc.CallOption) (*RPCDeleteSessionResponse, error) {
	out := new(RPCDeleteSessionResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/DeleteSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) GetSessionIdsByDetails(ctx context.Context, in *RPCGetSessionIdsByDetailsRequest, opts ...grpc.CallOption) (*RPCGetSessionIdsResponse, error) {
	out := new(RPCGetSessionIdsResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetSessionIdsByDetails", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) GetSessionIdsByPeerIds(ctx context.Context, in *RPCGetSessionIdsByPeerIdsRequest, opts ...grpc.CallOption) (*RPCGetSessionIdsResponse, error) {
	out := new(RPCGetSessionIdsResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetSessionIdsByPeerIds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) GetSession(ctx context.Context, in *RPCGetSessionRequest, opts ...grpc.CallOption) (*RPCGetSessionResponse, error) {
	out := new(RPCGetSessionResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) UpsertPeer(ctx context.Context, in *RPCUpsertPeerRequest, opts ...grpc.CallOption) (*RPCUpsertPeerResponse, error) {
	out := new(RPCUpsertPeerResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/UpsertPeer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) GetPeerIds(ctx context.Context, in *RPCGetPeerIdsRequest, opts ...grpc.CallOption) (*RPCGetPeerIdsResponse, error) {
	out := new(RPCGetPeerIdsResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetPeerIds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) GetPeer(ctx context.Context, in *RPCGetPeerRequest, opts ...grpc.CallOption) (*RPCGetPeerResponse, error) {
	out := new(RPCGetPeerResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetPeer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) WritePeerFile(ctx context.Context, in *RPCWritePeerFileRequest, opts ...grpc.CallOption) (*RPCWritePeerFileResponse, error) {
	out := new(RPCWritePeerFileResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/WritePeerFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) GetPeerFile(ctx context.Context, in *RPCGetPeerFileRequest, opts ...grpc.CallOption) (*RPCGetPeerFileResponse, error) {
	out := new(RPCGetPeerFileResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetPeerFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) SendDirectMessage(ctx context.Context, in *RPCDirectMessage, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/SendDirectMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) ReceiveDirectMessage(ctx context.Context, in *RPCReceiveDirectMessageRequest, opts ...grpc.CallOption) (Decentralizer_ReceiveDirectMessageClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Decentralizer_serviceDesc.Streams[0], c.cc, "/pb.Decentralizer/ReceiveDirectMessage", opts...)
	if err != nil {
		return nil, err
	}
	x := &decentralizerReceiveDirectMessageClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Decentralizer_ReceiveDirectMessageClient interface {
	Recv() (*RPCDirectMessage, error)
	grpc.ClientStream
}

type decentralizerReceiveDirectMessageClient struct {
	grpc.ClientStream
}

func (x *decentralizerReceiveDirectMessageClient) Recv() (*RPCDirectMessage, error) {
	m := new(RPCDirectMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *decentralizerClient) ReadPublisherDefinition(ctx context.Context, in *LoadPublisherDefinitionRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/readPublisherDefinition", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) PublishPublisherUpdate(ctx context.Context, in *RPCPublishPublisherUpdateRequest, opts ...grpc.CallOption) (*DNPublisherRecord, error) {
	out := new(DNPublisherRecord)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/publishPublisherUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) GetPublisherDefinition(ctx context.Context, in *GetPublisherDefinitionRequest, opts ...grpc.CallOption) (*PublisherDefinition, error) {
	out := new(PublisherDefinition)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetPublisherDefinition", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) GetPublisherFile(ctx context.Context, in *RPCGetPublisherFileRequest, opts ...grpc.CallOption) (*RPCGetPublisherFileResponse, error) {
	out := new(RPCGetPublisherFileResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetPublisherFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Decentralizer service

type DecentralizerServer interface {
	//
	// Platform
	//
	// Get health of decentralizer.
	GetHealth(context.Context, *RPCHealthRequest) (*RPCHealthReply, error)
	//
	// Matchmaking
	//
	// Create or update a session. Takes session info, returns session id.
	UpsertSession(context.Context, *RPCUpsertSessionRequest) (*RPCUpsertSessionResponse, error)
	// Delete a session. Takes session id, returns bool informing if the deletion was a success
	DeleteSession(context.Context, *RPCDeleteSessionRequest) (*RPCDeleteSessionResponse, error)
	// Get session ids. Takes session type, and a key and value to filter the sessions by details. If left empty this filter will not apply and all will be fetched.
	GetSessionIdsByDetails(context.Context, *RPCGetSessionIdsByDetailsRequest) (*RPCGetSessionIdsResponse, error)
	// Get session ids. Takes peer ids. Returns session ids
	GetSessionIdsByPeerIds(context.Context, *RPCGetSessionIdsByPeerIdsRequest) (*RPCGetSessionIdsResponse, error)
	// Get an individual session. Takes session id and returns session info.
	GetSession(context.Context, *RPCGetSessionRequest) (*RPCGetSessionResponse, error)
	//
	// Address book
	//
	// Create or update a peer. Takes peer info, returns if it was a success.
	UpsertPeer(context.Context, *RPCUpsertPeerRequest) (*RPCUpsertPeerResponse, error)
	// Get peer ids. takes a key and value to filter the peers by details. If left empty this filter will not apply and all will be fetched.
	GetPeerIds(context.Context, *RPCGetPeerIdsRequest) (*RPCGetPeerIdsResponse, error)
	// Get an individual peer. Takes either a peer id or decentralizer id and returns the peer info.
	GetPeer(context.Context, *RPCGetPeerRequest) (*RPCGetPeerResponse, error)
	//
	// Storage
	//
	// Write a peer file. Takes a file name and the data it should save.
	WritePeerFile(context.Context, *RPCWritePeerFileRequest) (*RPCWritePeerFileResponse, error)
	// Get a peer file. Takes a file name, returns the file.
	GetPeerFile(context.Context, *RPCGetPeerFileRequest) (*RPCGetPeerFileResponse, error)
	//
	// Messaging
	//
	// Send another peer a direct message. Takes a peer id and the data it should send
	SendDirectMessage(context.Context, *RPCDirectMessage) (*Empty, error)
	ReceiveDirectMessage(*RPCReceiveDirectMessageRequest, Decentralizer_ReceiveDirectMessageServer) error
	//
	// Publisher
	//
	// Load a publisher definition. Will not work if its older!
	ReadPublisherDefinition(context.Context, *LoadPublisherDefinitionRequest) (*Empty, error)
	// Signs a new publisher update. (Only if you have the private key!)
	PublishPublisherUpdate(context.Context, *RPCPublishPublisherUpdateRequest) (*DNPublisherRecord, error)
	// Get the full publisher definition
	GetPublisherDefinition(context.Context, *GetPublisherDefinitionRequest) (*PublisherDefinition, error)
	// Get a publisher file.
	GetPublisherFile(context.Context, *RPCGetPublisherFileRequest) (*RPCGetPublisherFileResponse, error)
}

func RegisterDecentralizerServer(s *grpc.Server, srv DecentralizerServer) {
	s.RegisterService(&_Decentralizer_serviceDesc, srv)
}

func _Decentralizer_GetHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCHealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetHealth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetHealth(ctx, req.(*RPCHealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_UpsertSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCUpsertSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).UpsertSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/UpsertSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).UpsertSession(ctx, req.(*RPCUpsertSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_DeleteSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCDeleteSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).DeleteSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/DeleteSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).DeleteSession(ctx, req.(*RPCDeleteSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_GetSessionIdsByDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCGetSessionIdsByDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetSessionIdsByDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetSessionIdsByDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetSessionIdsByDetails(ctx, req.(*RPCGetSessionIdsByDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_GetSessionIdsByPeerIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCGetSessionIdsByPeerIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetSessionIdsByPeerIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetSessionIdsByPeerIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetSessionIdsByPeerIds(ctx, req.(*RPCGetSessionIdsByPeerIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_GetSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCGetSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetSession(ctx, req.(*RPCGetSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_UpsertPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCUpsertPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).UpsertPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/UpsertPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).UpsertPeer(ctx, req.(*RPCUpsertPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_GetPeerIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCGetPeerIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetPeerIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetPeerIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetPeerIds(ctx, req.(*RPCGetPeerIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_GetPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCGetPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetPeer(ctx, req.(*RPCGetPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_WritePeerFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCWritePeerFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).WritePeerFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/WritePeerFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).WritePeerFile(ctx, req.(*RPCWritePeerFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_GetPeerFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCGetPeerFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetPeerFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetPeerFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetPeerFile(ctx, req.(*RPCGetPeerFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_SendDirectMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCDirectMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).SendDirectMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/SendDirectMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).SendDirectMessage(ctx, req.(*RPCDirectMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_ReceiveDirectMessage_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RPCReceiveDirectMessageRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DecentralizerServer).ReceiveDirectMessage(m, &decentralizerReceiveDirectMessageServer{stream})
}

type Decentralizer_ReceiveDirectMessageServer interface {
	Send(*RPCDirectMessage) error
	grpc.ServerStream
}

type decentralizerReceiveDirectMessageServer struct {
	grpc.ServerStream
}

func (x *decentralizerReceiveDirectMessageServer) Send(m *RPCDirectMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _Decentralizer_ReadPublisherDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadPublisherDefinitionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).ReadPublisherDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/ReadPublisherDefinition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).ReadPublisherDefinition(ctx, req.(*LoadPublisherDefinitionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_PublishPublisherUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCPublishPublisherUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).PublishPublisherUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/PublishPublisherUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).PublishPublisherUpdate(ctx, req.(*RPCPublishPublisherUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_GetPublisherDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPublisherDefinitionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetPublisherDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetPublisherDefinition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetPublisherDefinition(ctx, req.(*GetPublisherDefinitionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_GetPublisherFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCGetPublisherFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetPublisherFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetPublisherFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetPublisherFile(ctx, req.(*RPCGetPublisherFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Decentralizer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Decentralizer",
	HandlerType: (*DecentralizerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetHealth",
			Handler:    _Decentralizer_GetHealth_Handler,
		},
		{
			MethodName: "UpsertSession",
			Handler:    _Decentralizer_UpsertSession_Handler,
		},
		{
			MethodName: "DeleteSession",
			Handler:    _Decentralizer_DeleteSession_Handler,
		},
		{
			MethodName: "GetSessionIdsByDetails",
			Handler:    _Decentralizer_GetSessionIdsByDetails_Handler,
		},
		{
			MethodName: "GetSessionIdsByPeerIds",
			Handler:    _Decentralizer_GetSessionIdsByPeerIds_Handler,
		},
		{
			MethodName: "GetSession",
			Handler:    _Decentralizer_GetSession_Handler,
		},
		{
			MethodName: "UpsertPeer",
			Handler:    _Decentralizer_UpsertPeer_Handler,
		},
		{
			MethodName: "GetPeerIds",
			Handler:    _Decentralizer_GetPeerIds_Handler,
		},
		{
			MethodName: "GetPeer",
			Handler:    _Decentralizer_GetPeer_Handler,
		},
		{
			MethodName: "WritePeerFile",
			Handler:    _Decentralizer_WritePeerFile_Handler,
		},
		{
			MethodName: "GetPeerFile",
			Handler:    _Decentralizer_GetPeerFile_Handler,
		},
		{
			MethodName: "SendDirectMessage",
			Handler:    _Decentralizer_SendDirectMessage_Handler,
		},
		{
			MethodName: "readPublisherDefinition",
			Handler:    _Decentralizer_ReadPublisherDefinition_Handler,
		},
		{
			MethodName: "publishPublisherUpdate",
			Handler:    _Decentralizer_PublishPublisherUpdate_Handler,
		},
		{
			MethodName: "GetPublisherDefinition",
			Handler:    _Decentralizer_GetPublisherDefinition_Handler,
		},
		{
			MethodName: "GetPublisherFile",
			Handler:    _Decentralizer_GetPublisherFile_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ReceiveDirectMessage",
			Handler:       _Decentralizer_ReceiveDirectMessage_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pb/platform.proto",
}

func init() { proto.RegisterFile("pb/platform.proto", fileDescriptor3) }

var fileDescriptor3 = []byte{
	// 750 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0xdd, 0x4e, 0xdb, 0x48,
	0x14, 0x4e, 0xd8, 0x65, 0x81, 0x61, 0xc3, 0xc2, 0x6c, 0xfe, 0xc8, 0xb2, 0x0b, 0x78, 0xd1, 0x8a,
	0xed, 0x05, 0xee, 0x9f, 0xfa, 0x00, 0x25, 0xe2, 0xa7, 0x82, 0x2a, 0x0a, 0x45, 0xdc, 0xb5, 0x1a,
	0xc7, 0x87, 0xc4, 0x8a, 0xe3, 0x19, 0x3c, 0x13, 0xaa, 0xd4, 0xca, 0x4d, 0x55, 0xa9, 0x0f, 0xd0,
	0xbb, 0xbe, 0x56, 0x5f, 0xa1, 0x0f, 0x52, 0x79, 0x3c, 0x63, 0xec, 0x61, 0x90, 0x7a, 0xe9, 0xef,
	0x9b, 0xf3, 0x7d, 0xdf, 0xf1, 0xf1, 0x1c, 0xa3, 0x0d, 0xe6, 0xb9, 0x2c, 0x24, 0xe2, 0x9a, 0xc6,
	0x93, 0x03, 0x16, 0x53, 0x41, 0xf1, 0x02, 0xf3, 0x3a, 0x75, 0xe6, 0xb9, 0x13, 0x22, 0x06, 0xa3,
	0x09, 0x19, 0x07, 0xd1, 0x30, 0x63, 0x24, 0x4a, 0x7c, 0x3f, 0x06, 0xce, 0x3d, 0x4a, 0xc7, 0x0a,
	0x5d, 0x67, 0x9e, 0xcb, 0x05, 0x8d, 0xc9, 0x10, 0x14, 0x82, 0xd3, 0x6a, 0xe0, 0x9c, 0x0c, 0xef,
	0x6a, 0x53, 0x8c, 0x4d, 0xbd, 0x30, 0xe0, 0x23, 0x88, 0x15, 0xb6, 0x35, 0xa4, 0x74, 0x18, 0x82,
	0x4b, 0x58, 0xe0, 0x92, 0x28, 0xa2, 0x82, 0x88, 0x80, 0x46, 0x3c, 0x63, 0x9d, 0x25, 0xb4, 0x08,
	0x13, 0x26, 0x66, 0xce, 0x09, 0x5a, 0xef, 0xf7, 0x0e, 0x4f, 0x80, 0x84, 0x62, 0xd4, 0x87, 0x9b,
	0x29, 0x70, 0x81, 0x9f, 0xa3, 0xc6, 0x7b, 0x12, 0x88, 0x23, 0x1a, 0x9f, 0x07, 0xd1, 0x21, 0x8d,
	0x22, 0x18, 0xc8, 0xda, 0x76, 0x75, 0xa7, 0xba, 0xbf, 0xdc, 0xb7, 0x93, 0xce, 0xa7, 0x2a, 0x5a,
	0x2b, 0x48, 0xb1, 0x70, 0x86, 0xeb, 0x68, 0x31, 0x06, 0xe2, 0xcf, 0x54, 0x61, 0xf6, 0x80, 0xdb,
	0x68, 0x29, 0x6b, 0x00, 0xda, 0x0b, 0x3b, 0xd5, 0xfd, 0x95, 0xbe, 0x7e, 0xc4, 0x1d, 0xb4, 0xec,
	0x11, 0x0e, 0x3d, 0x22, 0x46, 0xed, 0x5f, 0x24, 0x95, 0x3f, 0xe3, 0xff, 0xd0, 0x5a, 0x34, 0x9d,
	0x14, 0xd3, 0xfc, 0xba, 0x53, 0xdd, 0xaf, 0xf5, 0x0d, 0xf4, 0xe9, 0xd7, 0xdf, 0x51, 0xad, 0x0b,
	0x03, 0x88, 0x44, 0x4c, 0xc2, 0xe0, 0x03, 0xc4, 0x98, 0xa0, 0x95, 0x63, 0x10, 0x59, 0x2e, 0x5c,
	0x3f, 0x60, 0xde, 0x81, 0xd9, 0x71, 0x07, 0x1b, 0x28, 0x0b, 0x67, 0xce, 0xa3, 0x8f, 0xdf, 0xbe,
	0x7f, 0x59, 0xd8, 0xc3, 0x8e, 0x7b, 0xfb, 0xc4, 0x1d, 0x49, 0xc2, 0x4d, 0xac, 0xad, 0xcf, 0xf1,
	0x3b, 0x54, 0xbb, 0x64, 0x1c, 0x62, 0x71, 0x01, 0x9c, 0x07, 0x34, 0xc2, 0x7f, 0x29, 0xc1, 0x12,
	0xaa, 0xdd, 0xb6, 0xec, 0x24, 0x67, 0x34, 0xe2, 0xe0, 0xfc, 0x29, 0x7d, 0x6b, 0xce, 0x6a, 0xea,
	0xcb, 0x95, 0xde, 0x59, 0xda, 0x54, 0x08, 0x02, 0x4c, 0x83, 0x12, 0x6a, 0x1a, 0x18, 0xa4, 0x32,
	0xa8, 0xe0, 0xcf, 0x55, 0xd4, 0x3c, 0x06, 0xed, 0x7c, 0xea, 0xf3, 0x97, 0xb3, 0x2e, 0x08, 0x12,
	0x84, 0x1c, 0xef, 0xa9, 0x52, 0x3b, 0x6d, 0x1a, 0x94, 0x4e, 0xe5, 0x06, 0xff, 0xcb, 0x0e, 0xfe,
	0xc5, 0xbb, 0x85, 0x0e, 0xb8, 0x9b, 0x88, 0x19, 0x83, 0xb9, 0x9b, 0x8c, 0x61, 0x36, 0x77, 0x93,
	0x5b, 0x12, 0x4e, 0x61, 0x8e, 0xdf, 0xde, 0x0b, 0xd2, 0x03, 0x88, 0x4f, 0xfd, 0x07, 0x83, 0x28,
	0xfa, 0xe7, 0x82, 0x54, 0xb0, 0x87, 0xd0, 0x1d, 0x85, 0xdb, 0xf7, 0x4e, 0x6b, 0x9d, 0x4d, 0x0b,
	0xa3, 0x44, 0xb6, 0x65, 0x37, 0x9b, 0xb8, 0x55, 0xe8, 0xc6, 0x4d, 0xb8, 0x76, 0x9b, 0xe3, 0x43,
	0x84, 0xb2, 0x49, 0xa6, 0xd9, 0x72, 0x8f, 0x3b, 0xc8, 0xf4, 0x28, 0x32, 0x46, 0x50, 0xdd, 0x7c,
	0x21, 0xa8, 0xd1, 0xf0, 0xa6, 0x85, 0xb1, 0x05, 0x65, 0x00, 0x31, 0x37, 0x5e, 0xf6, 0x15, 0x5a,
	0x52, 0x65, 0xb8, 0x51, 0x96, 0xd1, 0xea, 0x4d, 0x13, 0x56, 0xd2, 0x7f, 0x4b, 0xe9, 0x16, 0x6e,
	0x68, 0x69, 0x37, 0x61, 0xa7, 0xfe, 0xdc, 0x4d, 0x7c, 0xf9, 0x06, 0xce, 0x50, 0xed, 0x2a, 0x0e,
	0x04, 0xa4, 0x35, 0x47, 0x41, 0x08, 0xf9, 0xd7, 0x59, 0x42, 0xcd, 0x99, 0x19, 0x64, 0xfe, 0x2a,
	0x8e, 0xd0, 0xaa, 0xf2, 0x97, 0x5a, 0x46, 0xc7, 0x45, 0xa5, 0x8e, 0x8d, 0xca, 0x75, 0x5e, 0xa0,
	0x8d, 0x0b, 0x88, 0xfc, 0x6e, 0x10, 0xc3, 0x40, 0x9c, 0xab, 0x15, 0xa3, 0xef, 0x7f, 0x09, 0xed,
	0xac, 0xa4, 0x68, 0xb6, 0x10, 0x2b, 0xf8, 0x0d, 0xaa, 0xf7, 0x61, 0x00, 0xc1, 0x2d, 0x94, 0x4b,
	0x1d, 0x55, 0x6a, 0x23, 0x75, 0x22, 0xab, 0xbc, 0x53, 0x79, 0x5c, 0xc5, 0xaf, 0x50, 0x2b, 0x5d,
	0x7f, 0x3d, 0xbd, 0xa6, 0xbb, 0x70, 0x1d, 0x44, 0x41, 0xba, 0x3f, 0x32, 0xe1, 0x90, 0x5a, 0x49,
	0x2d, 0x5c, 0x4a, 0x78, 0x85, 0x9a, 0x6a, 0xdd, 0xe7, 0x15, 0x97, 0xcc, 0x27, 0x02, 0xf2, 0x5b,
	0xd3, 0xb3, 0xd2, 0x5a, 0x4c, 0x4e, 0xbf, 0xfb, 0x3a, 0x67, 0xfb, 0x30, 0xa0, 0xb1, 0xef, 0x54,
	0xf0, 0x58, 0x5e, 0x47, 0x5b, 0xc6, 0xdd, 0xb4, 0xc4, 0xce, 0x69, 0xd5, 0x56, 0x7a, 0xc4, 0xc2,
	0x3b, 0x0d, 0xf9, 0xf5, 0xfc, 0x81, 0x6b, 0xf2, 0xeb, 0xd1, 0x07, 0xf0, 0x0d, 0x5a, 0x2f, 0x0a,
	0xca, 0x61, 0xff, 0x53, 0x98, 0x68, 0x91, 0xd0, 0x1e, 0xdb, 0x0f, 0xf2, 0x6a, 0xec, 0x5b, 0xd2,
	0xab, 0x89, 0xeb, 0x25, 0x2f, 0x37, 0x89, 0xc8, 0x04, 0xe6, 0xde, 0x6f, 0xf2, 0xef, 0xf7, 0xec,
	0x47, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4b, 0x93, 0xe2, 0x27, 0x9a, 0x07, 0x00, 0x00,
}
