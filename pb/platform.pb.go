// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pb/platform.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type RPCHealthRequest struct {
}

func (m *RPCHealthRequest) Reset()                    { *m = RPCHealthRequest{} }
func (m *RPCHealthRequest) String() string            { return proto.CompactTextString(m) }
func (*RPCHealthRequest) ProtoMessage()               {}
func (*RPCHealthRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

type RPCHealthReply struct {
	Ready   bool   `protobuf:"varint,1,opt,name=ready" json:"ready,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *RPCHealthReply) Reset()                    { *m = RPCHealthReply{} }
func (m *RPCHealthReply) String() string            { return proto.CompactTextString(m) }
func (*RPCHealthReply) ProtoMessage()               {}
func (*RPCHealthReply) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *RPCHealthReply) GetReady() bool {
	if m != nil {
		return m.Ready
	}
	return false
}

func (m *RPCHealthReply) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*RPCHealthRequest)(nil), "pb.RPCHealthRequest")
	proto.RegisterType((*RPCHealthReply)(nil), "pb.RPCHealthReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Decentralizer service

type DecentralizerClient interface {
	//
	// Platform
	//
	// Get health of decentralizer.
	GetHealth(ctx context.Context, in *RPCHealthRequest, opts ...grpc.CallOption) (*RPCHealthReply, error)
	//
	// Matchmaking
	//
	// Create or update a session. Takes session info, returns session id.
	UpsertSession(ctx context.Context, in *RPCUpsertSessionRequest, opts ...grpc.CallOption) (*RPCUpsertSessionResponse, error)
	// Delete a session. Takes session id, returns bool informing if the deletion was a success
	DeleteSession(ctx context.Context, in *RPCDeleteSessionRequest, opts ...grpc.CallOption) (*RPCDeleteSessionResponse, error)
	// Get session ids. Takes session type, and a key and value to filter the sessions by details. If left empty this filter will not apply  and all will be fetched.
	GetSessionIds(ctx context.Context, in *RPCGetSessionIdsRequest, opts ...grpc.CallOption) (*RPCGetSessionIdsResponse, error)
	// Get an individual session. Takes session id and returns session info.
	GetSession(ctx context.Context, in *RPCGetSessionRequest, opts ...grpc.CallOption) (*RPCGetSessionResponse, error)
	//
	// Address book
	//
	// Create or update a peer. Takes peer info, returns if it was a success.
	UpsertPeer(ctx context.Context, in *RPCUpsertPeerRequest, opts ...grpc.CallOption) (*RPCUpsertPeerResponse, error)
	// Get peer ids. takes a key and value to filter the peers by details. If left empty this filter will not apply and all will be fetched.
	GetPeerIds(ctx context.Context, in *RPCGetPeerIdsRequest, opts ...grpc.CallOption) (*RPCGetPeerIdsResponse, error)
	// Get an individual peer. Takes either a peer id or decentralizer id and returns the peer info.
	GetPeer(ctx context.Context, in *RPCGetPeerRequest, opts ...grpc.CallOption) (*RPCGetPeerResponse, error)
}

type decentralizerClient struct {
	cc *grpc.ClientConn
}

func NewDecentralizerClient(cc *grpc.ClientConn) DecentralizerClient {
	return &decentralizerClient{cc}
}

func (c *decentralizerClient) GetHealth(ctx context.Context, in *RPCHealthRequest, opts ...grpc.CallOption) (*RPCHealthReply, error) {
	out := new(RPCHealthReply)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetHealth", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) UpsertSession(ctx context.Context, in *RPCUpsertSessionRequest, opts ...grpc.CallOption) (*RPCUpsertSessionResponse, error) {
	out := new(RPCUpsertSessionResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/UpsertSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) DeleteSession(ctx context.Context, in *RPCDeleteSessionRequest, opts ...grpc.CallOption) (*RPCDeleteSessionResponse, error) {
	out := new(RPCDeleteSessionResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/DeleteSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) GetSessionIds(ctx context.Context, in *RPCGetSessionIdsRequest, opts ...grpc.CallOption) (*RPCGetSessionIdsResponse, error) {
	out := new(RPCGetSessionIdsResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetSessionIds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) GetSession(ctx context.Context, in *RPCGetSessionRequest, opts ...grpc.CallOption) (*RPCGetSessionResponse, error) {
	out := new(RPCGetSessionResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) UpsertPeer(ctx context.Context, in *RPCUpsertPeerRequest, opts ...grpc.CallOption) (*RPCUpsertPeerResponse, error) {
	out := new(RPCUpsertPeerResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/UpsertPeer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) GetPeerIds(ctx context.Context, in *RPCGetPeerIdsRequest, opts ...grpc.CallOption) (*RPCGetPeerIdsResponse, error) {
	out := new(RPCGetPeerIdsResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetPeerIds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decentralizerClient) GetPeer(ctx context.Context, in *RPCGetPeerRequest, opts ...grpc.CallOption) (*RPCGetPeerResponse, error) {
	out := new(RPCGetPeerResponse)
	err := grpc.Invoke(ctx, "/pb.Decentralizer/GetPeer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Decentralizer service

type DecentralizerServer interface {
	//
	// Platform
	//
	// Get health of decentralizer.
	GetHealth(context.Context, *RPCHealthRequest) (*RPCHealthReply, error)
	//
	// Matchmaking
	//
	// Create or update a session. Takes session info, returns session id.
	UpsertSession(context.Context, *RPCUpsertSessionRequest) (*RPCUpsertSessionResponse, error)
	// Delete a session. Takes session id, returns bool informing if the deletion was a success
	DeleteSession(context.Context, *RPCDeleteSessionRequest) (*RPCDeleteSessionResponse, error)
	// Get session ids. Takes session type, and a key and value to filter the sessions by details. If left empty this filter will not apply  and all will be fetched.
	GetSessionIds(context.Context, *RPCGetSessionIdsRequest) (*RPCGetSessionIdsResponse, error)
	// Get an individual session. Takes session id and returns session info.
	GetSession(context.Context, *RPCGetSessionRequest) (*RPCGetSessionResponse, error)
	//
	// Address book
	//
	// Create or update a peer. Takes peer info, returns if it was a success.
	UpsertPeer(context.Context, *RPCUpsertPeerRequest) (*RPCUpsertPeerResponse, error)
	// Get peer ids. takes a key and value to filter the peers by details. If left empty this filter will not apply and all will be fetched.
	GetPeerIds(context.Context, *RPCGetPeerIdsRequest) (*RPCGetPeerIdsResponse, error)
	// Get an individual peer. Takes either a peer id or decentralizer id and returns the peer info.
	GetPeer(context.Context, *RPCGetPeerRequest) (*RPCGetPeerResponse, error)
}

func RegisterDecentralizerServer(s *grpc.Server, srv DecentralizerServer) {
	s.RegisterService(&_Decentralizer_serviceDesc, srv)
}

func _Decentralizer_GetHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCHealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetHealth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetHealth(ctx, req.(*RPCHealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_UpsertSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCUpsertSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).UpsertSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/UpsertSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).UpsertSession(ctx, req.(*RPCUpsertSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_DeleteSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCDeleteSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).DeleteSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/DeleteSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).DeleteSession(ctx, req.(*RPCDeleteSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_GetSessionIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCGetSessionIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetSessionIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetSessionIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetSessionIds(ctx, req.(*RPCGetSessionIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_GetSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCGetSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetSession(ctx, req.(*RPCGetSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_UpsertPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCUpsertPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).UpsertPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/UpsertPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).UpsertPeer(ctx, req.(*RPCUpsertPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_GetPeerIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCGetPeerIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetPeerIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetPeerIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetPeerIds(ctx, req.(*RPCGetPeerIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Decentralizer_GetPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCGetPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecentralizerServer).GetPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Decentralizer/GetPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecentralizerServer).GetPeer(ctx, req.(*RPCGetPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Decentralizer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Decentralizer",
	HandlerType: (*DecentralizerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetHealth",
			Handler:    _Decentralizer_GetHealth_Handler,
		},
		{
			MethodName: "UpsertSession",
			Handler:    _Decentralizer_UpsertSession_Handler,
		},
		{
			MethodName: "DeleteSession",
			Handler:    _Decentralizer_DeleteSession_Handler,
		},
		{
			MethodName: "GetSessionIds",
			Handler:    _Decentralizer_GetSessionIds_Handler,
		},
		{
			MethodName: "GetSession",
			Handler:    _Decentralizer_GetSession_Handler,
		},
		{
			MethodName: "UpsertPeer",
			Handler:    _Decentralizer_UpsertPeer_Handler,
		},
		{
			MethodName: "GetPeerIds",
			Handler:    _Decentralizer_GetPeerIds_Handler,
		},
		{
			MethodName: "GetPeer",
			Handler:    _Decentralizer_GetPeer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/platform.proto",
}

func init() { proto.RegisterFile("pb/platform.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 312 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x92, 0x41, 0x4b, 0xc3, 0x30,
	0x14, 0xc7, 0xdd, 0x50, 0xe7, 0x02, 0x13, 0x0d, 0x53, 0xea, 0xf4, 0x30, 0x7a, 0xda, 0xa9, 0x03,
	0x3d, 0x08, 0x9e, 0x84, 0x0d, 0xa6, 0xe0, 0x61, 0x54, 0xfc, 0x00, 0xc9, 0xfa, 0xdc, 0xca, 0xd2,
	0x26, 0xe6, 0xc5, 0x43, 0xfd, 0x6e, 0x7e, 0x37, 0xd9, 0xd2, 0x74, 0x6d, 0xec, 0x31, 0xbf, 0xff,
	0x7b, 0xbf, 0xf7, 0x1e, 0x84, 0x5c, 0x2a, 0x3e, 0x55, 0x82, 0x99, 0x4f, 0xa9, 0xb3, 0x48, 0x69,
	0x69, 0x24, 0xed, 0x2a, 0x3e, 0x1a, 0x2a, 0x3e, 0xcd, 0x98, 0x59, 0x6d, 0x32, 0xb6, 0x4d, 0xf3,
	0xb5, 0x4d, 0xf6, 0x94, 0x25, 0x89, 0x06, 0x44, 0x2e, 0xe5, 0xd6, 0xd2, 0x90, 0x92, 0x8b, 0x78,
	0x39, 0x7b, 0x01, 0x26, 0xcc, 0x26, 0x86, 0xaf, 0x6f, 0x40, 0x13, 0x3e, 0x93, 0xf3, 0x1a, 0x53,
	0xa2, 0xa0, 0x43, 0x72, 0xa2, 0x81, 0x25, 0x45, 0xd0, 0x19, 0x77, 0x26, 0x67, 0xb1, 0x7d, 0xd0,
	0x80, 0xf4, 0x32, 0x40, 0x64, 0x6b, 0x08, 0xba, 0xe3, 0xce, 0xa4, 0x1f, 0xbb, 0xe7, 0xfd, 0xef,
	0x31, 0x19, 0xcc, 0x61, 0x05, 0xb9, 0xd1, 0x4c, 0xa4, 0x3f, 0xa0, 0xe9, 0x23, 0xe9, 0x2f, 0xc0,
	0x58, 0x27, 0x1d, 0x46, 0x8a, 0x47, 0xfe, 0xd8, 0x11, 0xf5, 0xa8, 0x12, 0x45, 0x78, 0x44, 0xdf,
	0xc8, 0xe0, 0x43, 0x21, 0x68, 0xf3, 0x0e, 0x88, 0xa9, 0xcc, 0xe9, 0x6d, 0x59, 0xd6, 0xa0, 0xce,
	0x71, 0xd7, 0x1e, 0xa2, 0x92, 0x39, 0x82, 0xb5, 0xcd, 0x41, 0x80, 0x01, 0xdf, 0xd6, 0xa0, 0xbe,
	0xcd, 0x0b, 0xeb, 0xb6, 0x05, 0xb8, 0x29, 0xaf, 0x09, 0x56, 0xb6, 0x06, 0xf5, 0x6d, 0x5e, 0x58,
	0xd9, 0x66, 0x84, 0x1c, 0x22, 0x1a, 0xfc, 0xab, 0x76, 0x9e, 0x9b, 0x96, 0xa4, 0x2e, 0xb1, 0xb7,
	0x2f, 0x01, 0x74, 0x25, 0x39, 0x20, 0x5f, 0x52, 0x4f, 0xbc, 0x4d, 0x76, 0x70, 0x77, 0x54, 0x6d,
	0x93, 0x12, 0xb5, 0x6c, 0x52, 0x25, 0x95, 0xe4, 0x89, 0xf4, 0x4a, 0x4e, 0xaf, 0x9a, 0x75, 0xae,
	0xfd, 0xda, 0xc7, 0xae, 0x97, 0x9f, 0xee, 0x3f, 0xe7, 0xc3, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xfc, 0x02, 0x32, 0x65, 0xe1, 0x02, 0x00, 0x00,
}
